<svg width="960" height="500">
  <path fill="none" stroke-width="10" style="stroke:black" d="
   M135,399C133.1785163608991,408.254976200606,172.90491357724812,437.54600139742024,179,434"></path>
</svg>

<script src="//d3js.org/d3.v4.min.js"></script>
<script>
  var asd = [

    [135.63705444335938, 321.8504943847656],
    [121.86421203613281, 336.8753967285156],
    [129.90863037109375, 328.09967041015625],
    [138.3185272216797, 318.92523193359375]];
  console.log('asd: ', asd);
  /*  var asd = [Â [238.49742126464844, 254.50584411621094],
    [229.00344848632812, 275.9921875],
    [238.50430297851324562, 254.49026489257812],
    [247.9947052001953, 233.01162719726562]];
    */
  console.log('asd: ', asd);
  var color = d3.interpolateYlGnBu;

  var path = d3.select("path").remove();
  console.log('path: ', path);

  d3.select("svg").selectAll("path")
    .data(quads(samples(path.node(), 8)))

    .enter().append("path")
    .style("fill", function (d) { return color(d.t); })
    .style("stroke", function (d) { return color(d.t); })
    .attr("d", function (d, i) {
      if (i === 0) {
        return lineJoin(asd[0], asd[1], asd[2], asd[3], 32);
      }
    });


  // Sample the SVG path uniformly with the specified precision.
  function samples(path, precision) {
    var n = path.getTotalLength(), t = [0], i = 0, dt = precision;
    while ((i += dt) < n) t.push(i);
    t.push(n);
    return t.map(function (t) {
      var p = path.getPointAtLength(t), a = [p.x, p.y];
      a.t = t / n;
      return a;
    });
  }

  // Compute quads of adjacent points [p0, p1, p2, p3].
  function quads(points) {
    return d3.range(points.length - 1).map(function (i) {
      var a = [points[i - 1], points[i], points[i + 1], points[i + 2]];
      a.t = (points[i].t + points[i + 1].t) / 2;
      return a;
    });
  }

  // Compute stroke outline for segment p12.
  function lineJoin(p0, p1, p2, p3, width) {
    var u12 = perp(p1, p2),
      r = width / 2,
      a = [p1[0] + u12[0] * r, p1[1] + u12[1] * r],
      b = [p2[0] + u12[0] * r, p2[1] + u12[1] * r],
      c = [p2[0] - u12[0] * r, p2[1] - u12[1] * r],
      d = [p1[0] - u12[0] * r, p1[1] - u12[1] * r];
      console.log('d: ', d);

    /*if (p0) { // clip ad and dc using average of u01 and u12
      var u01 = perp(p0, p1), e = [p1[0] + u01[0] + u12[0], p1[1] + u01[1] + u12[1]];
      a = lineIntersect(p1, e, a, b);
      d = lineIntersect(p1, e, d, c);
    }

     if (p3) { 
       // clip ab and dc using average of u12 and u23
       var u23 = perp(p2, p3), e = [p2[0] + u23[0] + u12[0], p2[1] + u23[1] + u12[1]];
 
       
       b = lineIntersect(p2, e, a, b);
       
       c = lineIntersect(p2, e, d, c);
     }*/

    return "M" + a + "L" + b + " " + c + " " + d + "Z";
  }

  // Compute intersection of two infinite lines ab and cd.
  function lineIntersect(a, b, c, d) {
    console.log('d: ', d);
    console.log(' c: ', c);
    console.log('b: ', b);
    console.log('a: ', a);
    var x1 = c[0],
      x3 = a[0],
      x21 = d[0] - x1,
      x43 = b[0] - x3,
      y1 = c[1],

      y3 = a[1],

      y21 = d[1] - y1,

      y43 = b[1] - y3,
      ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    console.log(' x43 * y21: ', x43 * y21);
    console.log('y43 * x21: ', y43 * x21);
    console.log('y43 * (x1 - x3): ', y43 * (x1 - x3));
    console.log('x43 * (y1 - y3): ', x43 * (y1 - y3));
    console.log('x43: ', x43);
    console.log('y21: ', y21);
    console.log('y43: ', y43); console.log('y1: ', y1);
    console.log('y3: ', y3);
    console.log('ua: ', ua);
    console.log('x21: ', x21);
    console.log('x1: ', x1); console.log('x1 + ua * x21: ', x1 + ua * x21); console.log('y1 + ua * y21: ', y1 + ua * y21);
    return [x1 + ua * x21, y1 + ua * y21];


  }

  // Compute unit vector perpendicular to p01.
  function perp(p0, p1) {
    var u01x = p0[1] - p1[1], u01y = p1[0] - p0[0],
      u01d = Math.sqrt(u01x * u01x + u01y * u01y);
    return [u01x / u01d, u01y / u01d];
  }

</script>