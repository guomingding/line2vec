<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ=="
        crossorigin="" />
    <link href="bootstrap-3.3.7-dist/css/bootstrap-theme.min.css" rel="stylesheet" />
    <link href="bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="bootstrap-3.3.7-dist/css/bootstrap-combobox.css" type="text/css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="leaflet/debug/css/screen.css" />

    <title>Document</title>


    <style type="text/css">
        html,
        body {
            margin: 0;
            padding: 0;
            background-color: #EEE;
            height: 1000px;
        }

        .side {
            height: 800px;
            position: absolute;
            width: 220px;
            padding: 8px;
            padding-right: 5px;
        }

        .be-content {
            position: absolute;
            margin-left: 220px;
            height: 100%;
            margin-top: 8px;
        }

        .panel {
            height: 100%;
        }

        #map {
            height: 500px;
            width: 600px;
            background-color: #fff;
            margin: 0;
            padding: 0;
        }

        #scatterPlot {
            background-color: #fff;
            border-radius: 4px;
            margin: 0px 0px 0px 4px;
            padding: 0;
            height: 500px;
            width: 500px;
        }

        #network {
            margin: 4px 0px 0px 0px;
            padding: 0;
            height: 279px;
            width: 600px;
        }

        #evaluate {
            margin: 4px 0px 0px 4px;
            padding: 0;
            height: 279px;
            width: 500px;
        }

        .panel-heading {
            padding-top: 5px;
            padding-bottom: 5px;
            text-align: center;
        }

        .panel-heading {
            font-weight: 600;
        }

        .row {
            display: flex;
        }
    </style>
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log=="
        crossorigin=""></script>
    <script src="js/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="js/jquery-3.3.1.min.js"></script>
    <script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <script src="js/pixi.min.js"></script>
</head>

<body>
    <div>
        <div class="side">
            <div class="panel panel-default">
                <div class="panel-heading">control panel</div>
                <div class="panel-body">
                    <button type="button" class="btn btn-default" id="sample" align="center" style="text-align:center;font-size:17px;position:absolute;top:50px;left:30px;width:150px;height:40px;margin:6px">
                        Sample
                    </button>
                </div>
            </div>
        </div>
        <div class="be-content">
            <div class="main-content container-fluid">
                <div class="row">
                    <div class="col-md-8 panel panel-default" id="map">
                    </div>
                    <div class="col-md-4 panel panel-default" id="scatterPlot">
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-8 panel panel-default" id="network">
                    </div>
                    <div class="col-md-4 panel panel-default" id="evaluate">
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script type="text/javascript">
        $("button").button();

        var map = L.map('map', {
            renderer: L.canvas()
        }).setView([41.8952, -87.67965], 11);
        var osmUrl = 'http://localhost/Tiles/{z}/{x}/{y}.png',
            layer = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>'
        L.tileLayer(osmUrl, {
            minZoom: 10,
            maxZoom: 17,
            //用了mapbox的图层
            attribution: layer,
            //访问令牌
            accessToken: 'your.mapbox.access.token'
        }).addTo(map);
        map.setMaxBounds([
            [42.057620221480988, -88.190469752006366],
            [41.647619270576612, -87.049977568912865]
        ]);


        function preprocessingData(mapData, scatterData, sampledScatterData) {
            console.time("preprocessingData");
            scatterData.forEach(element => {
                element.x = parseFloat(element.x);
                element.y = parseFloat(element.y);
                element.scor = [parseFloat(element.slat), parseFloat(element.slng)];
                element.tcor = [parseFloat(element.tlat), parseFloat(element.tlng)];
                element.label = parseFloat(element.label);
            });
            sampledScatterData.forEach(element => {
                element.x = parseFloat(element.x);
                element.y = parseFloat(element.y);
                element.scor = [parseFloat(element.slat), parseFloat(element.slng)];
                element.tcor = [parseFloat(element.tlat), parseFloat(element.tlng)];
                element.label = parseFloat(element.label);
            });
            mapData.forEach(element => {
                element.stationID = parseFloat(element.stationID);
                element.stationLocation = [parseFloat(element.stationLat), parseFloat(element.stationLng)]
            });
            console.log('mapData', mapData);
            console.log('scatterData', scatterData);
            console.timeEnd("preprocessingData");
        }

        d3.csv("data/stationIDLocation.csv", (error, mapData) => {
            d3.csv("data/all_IDxyCoorsOnMapLabel.csv", (error, scatterData) => {
                d3.csv("data/sample2_IDxyCoorsOnMapLabel.csv", (error, sampledScatterData) => {
                    preprocessingData(mapData, scatterData, sampledScatterData);
                    var scatterPlotWidth = 500,
                        scatterPlotHeight = 500;
                    let stage = new PIXI.Container();
                    let renderer = PIXI.autoDetectRenderer(scatterPlotWidth, scatterPlotHeight,
                        { antialias: !0, transparent: !0, resolution: 1 });
                    document.getElementById("scatterPlot").appendChild(renderer.view);
                    var labelColorScale = d3.scale.category10();
                    var brushTime = 0;
                    var xyScale = getScatterXYScale(scatterData),
                        xScale = xyScale[0],
                        yScale = xyScale[1];
                    var formerSelectedCircle = [];
                    var laterSelectedCircle = [];
                    var recorder = [];
                    var polylines = [];
                    var sampled = false;
                    drawMapCircle(mapData);
                    //drawLines(scatterData);
                    drawScatterPlot(scatterData);
                    var brush = d3.brush()
                        .on("start brush", brushed)
                        .on("end", brushEnded);

                    var scatterSvg = d3.select("#scatterPlot")
                        .append("svg")
                        .attr("width", 500)
                        .attr("height", 500)
                        .style("position", "absolute")
                        .style("top", 0)
                        .style("left", 0);

                    scatterSvg.append("g")
                        .attr("class", "brush")
                        .call(brush)
                        .call(brush.move, [[100, 100], [200, 200]]);





                    function drawMapCircle(mapData) {
                        for (var i = 0; i < mapData.length; i++) {
                            L.circle(mapData[i].stationLocation,
                                {
                                    radius: 100,
                                    weight: 2,
                                    fillOpacity: 0.5,
                                }).addTo(map);
                        }
                    }
                    function drawLines(scatterData) {
                        if (polylines.length > 0) {
                            for (var i = 0; i < polylines.length; i++) {
                                map.removeLayer(polylines[i]);
                            }
                            polylines = [];
                        }
                        for (var i = 0; i < scatterData.length; i++) {
                            var scor = scatterData[i].scor;
                            var tcor = scatterData[i].tcor;
                            var polyline = L.polyline([scor, tcor],
                                {
                                    color: 'red',
                                    weight: 1,
                                    opacity: 0.3,
                                }).addTo(map);
                            polylines.push(polyline);
                        }
                    }
                    function getScatterXYScale(scatterData) {
                        var xMin = d3.min(scatterData, d => {
                            return d.x;
                        }),
                            xMax = d3.max(scatterData, d => {
                                return d.x;
                            }),
                            yMin = d3.min(scatterData, d => {
                                return d.y;
                            }),
                            yMax = d3.max(scatterData, d => {
                                return d.y;
                            });
                        var xScale = d3.scale.linear()
                            .domain([xMin, xMax])
                            .range([3, scatterPlotWidth - 3]);

                        var yScale = d3.scale.linear()
                            .domain([yMin, yMax])
                            .range([scatterPlotHeight - 3, 3]);
                        return [xScale, yScale];
                    }
                    function drawScatterPlot(scatterData) {
                        var xyScale = getScatterXYScale(scatterData),
                            xScale = xyScale[0];
                        yScale = xyScale[1];
                        var circle = new PIXI.Graphics();
                        for (var i = 0; i < scatterData.length; i++) {
                            circle.beginFill(labelColorScale(scatterData[i].label).replace('#', '0x'));
                            circle.drawCircle(xScale(scatterData[i].x), yScale(scatterData[i].y), 2);
                            circle.endFill();
                        }
                        circle.x = 0;
                        circle.y = 0;
                        stage.addChild(circle);
                        renderer.render(stage);
                    }

                    function drawScatterCircles(graphics, data, selectedBool) {
                        if (selectedBool == true) {
                            for (var i = 0; i < data.length; i++) {
                                graphics.beginFill(labelColorScale(data[i].label).replace('#', '0x'));
                                graphics.lineStyle(2, 0xFF0000);
                                graphics.drawCircle(xScale(data[i].x), yScale(data[i].y), 2);
                                graphics.endFill();
                            }
                            drawLines(data);
                            graphics.x = 0;
                            graphics.y = 0;
                        } else {
                            for (var i = 0; i < data.length; i++) {
                                graphics.beginFill(labelColorScale(data[i].label).replace('#', '0x'));
                                graphics.drawCircle(xScale(data[i].x), yScale(data[i].y), 2);
                                graphics.endFill();
                            }
                            graphics.x = 0;
                            graphics.y = 0;
                        }

                    }
                    function brushed() {
                        brushTime++;
                        if (brushTime === 2) {
                            var firstSeletedCircle = [];
                            unSelectedCircle = [];
                            for (var i = 0; i < scatterData.length; i++) {
                                var thisPoint = scatterData[i];
                                var cx = xScale(thisPoint.x);
                                var cy = yScale(thisPoint.y);
                                var s = d3.event.selection,
                                    x1 = s[0][0],
                                    y1 = s[0][1],
                                    x2 = s[1][0],
                                    y2 = s[1][1];
                                if (cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                                    firstSeletedCircle.push(thisPoint);
                                } else {
                                    unSelectedCircle.push(thisPoint);
                                }
                            }
                            formerSelectedCircle = firstSeletedCircle;

                            recorder.push(firstSeletedCircle);

                            //绘制

                            var firstCircle = new PIXI.Graphics();
                            drawScatterCircles(firstCircle, firstSeletedCircle, true);
                            stage.addChild(firstCircle);
                            var firstUsCircle = new PIXI.Graphics();
                            drawScatterCircles(firstUsCircle, unSelectedCircle, false);
                            stage.addChild(firstUsCircle);
                            renderer.render(stage);
                        } else if (brushTime > 2) {

                            var s = d3.event.selection,
                                x1 = s[0][0],
                                y1 = s[0][1],
                                x2 = s[1][0],
                                y2 = s[1][1];
                            var unSelectedCircle = [];
                            var laterSelectedCircle = [];
                            for (var i = 0; i < scatterData.length; i++) {
                                var thisPoint = scatterData[i];
                                var cx = xScale(thisPoint.x);
                                var cy = yScale(thisPoint.y);
                                if (cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                                    laterSelectedCircle.push(thisPoint);
                                } else {
                                    unSelectedCircle.push(thisPoint);
                                }
                            }
                            recorder.push(laterSelectedCircle);

                            if (recorder.length >= 2) {
                                formerSelectedCircle = recorder[0];
                                recorder.splice(0, 1);
                            }

                            var usRedrawCircle = [];
                            for (var i = 0; i < formerSelectedCircle.length; i++) {
                                if ($.inArray(formerSelectedCircle[i], laterSelectedCircle) == -1) {
                                    usRedrawCircle.push(formerSelectedCircle);
                                }
                            }
                            stage.removeChildAt(2);
                            stage.removeChildAt(1);
                            var sCircle = new PIXI.Graphics();
                            drawScatterCircles(sCircle, laterSelectedCircle, true);
                            stage.addChild(sCircle);
                            var usCircle = new PIXI.Graphics();
                            drawScatterCircles(usCircle, usRedrawCircle, false);
                            stage.addChild(usCircle);

                            renderer.render(stage);
                        }
                        //只有 这次选中的点 和 上次选中的点 需要重新绘制
                        //上次选中的点，如果不在这次选中的点之中，就按照未选中的状态重绘
                        //上次选中的点，如果在这次选中的点之中，就是把所有这次选中的点，按照选中的状态重绘
                        //这次和上次都没有选中的点，不变
                    }

                    function brushEnded() {

                    }


                    function brushSample() {
                        brushTime++;
                        if (brushTime === 2) {
                            var firstSeletedCircle = [];
                            unSelectedCircle = [];
                            for (var i = 0; i < sampledScatterData.length; i++) {
                                var thisPoint = sampledScatterData[i];
                                var cx = xScale(thisPoint.x);
                                var cy = yScale(thisPoint.y);
                                var s = d3.event.selection,
                                    x1 = s[0][0],
                                    y1 = s[0][1],
                                    x2 = s[1][0],
                                    y2 = s[1][1];
                                if (cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                                    firstSeletedCircle.push(thisPoint);
                                } else {
                                    unSelectedCircle.push(thisPoint);
                                }
                            }
                            formerSelectedCircle = firstSeletedCircle;
                            recorder.push(firstSeletedCircle);
                            var firstCircle = new PIXI.Graphics();
                            drawScatterCircles(firstCircle, firstSeletedCircle, true);
                            stage.addChild(firstCircle);
                            var firstUsCircle = new PIXI.Graphics();
                            drawScatterCircles(firstUsCircle, unSelectedCircle, false);
                            stage.addChild(firstUsCircle);
                            renderer.render(stage);
                        } else if (brushTime > 2) {
                            var s = d3.event.selection,
                                x1 = s[0][0],
                                y1 = s[0][1],
                                x2 = s[1][0],
                                y2 = s[1][1];
                            var unSelectedCircle = [];
                            var laterSelectedCircle = [];
                            for (var i = 0; i < sampledScatterData.length; i++) {
                                var thisPoint = sampledScatterData[i];
                                var cx = xScale(thisPoint.x);
                                var cy = yScale(thisPoint.y);
                                if (cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                                    laterSelectedCircle.push(thisPoint);
                                } else {
                                    unSelectedCircle.push(thisPoint);
                                }
                            }
                            recorder.push(laterSelectedCircle);

                            if (recorder.length >= 2) {
                                formerSelectedCircle = recorder[0];
                                recorder.splice(0, 1);
                            }

                            var usRedrawCircle = [];
                            for (var i = 0; i < formerSelectedCircle.length; i++) {
                                if ($.inArray(formerSelectedCircle[i], laterSelectedCircle) == -1) {
                                    usRedrawCircle.push(formerSelectedCircle);
                                }
                            }
                            stage.removeChildAt(2);
                            stage.removeChildAt(1);
                            var sCircle = new PIXI.Graphics();
                            drawScatterCircles(sCircle, laterSelectedCircle, true);
                            stage.addChild(sCircle);
                            var usCircle = new PIXI.Graphics();
                            drawScatterCircles(usCircle, usRedrawCircle, false);
                            stage.addChild(usCircle);

                            renderer.render(stage);
                        }
                        //在搜索选中点上还能加快速度
                    }
                    console.time("render");
                    renderer.render(stage);
                    console.timeEnd("render");

                    //在代码运行上如果设置sampled标志，在brush中再判断是否取样来绘制，还会有更多的执行语句
                    $("#sample").click(function () {
                        stage.removeChildren();
                        drawScatterPlot(sampledScatterData);
                        sampled = true;
                        brush.on("start brush", brushSample)
                            .on("end", brushEnded);
                        brushTime = 0;
                        d3.selectAll(".brush")
                            .call(brush)
                            .call(brush.move, [[100, 100], [200, 200]]);
                        // stage.removeChildren();
                        // drawScatterPlot(sampledScatterData);
                    });
                });
            });
        });//stationNameIDLocation.csv的括号
    </script>

</body>

</html>